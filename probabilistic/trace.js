
/*
Mapping (potentially long) absolute file names to unique integers 
*/
var fileNameTable =
{
	currId: 0,
	table: {},
	idForName: function(name)
	{
		var id = this.table[name]
		if (id == undefined) { id = this.currId++; this.table[name] = id }
		return id;
	}
}

/*
Code adapated from https://github.com/visionmedia/callsite/blob/master/index.js
*/
function getStack(numToSkip, numToGet)
{
	numToSkip = numToSkip || 0
	numToGet = numToGet || Infinity

	var origLimit = Error.stackTraceLimit
	Error.stackTraceLimit = numToGet

	var top = arguments.callee
	for (var i = 0; i < numToSkip; i++)
		top = top.caller

	var orig = Error.prepareStackTrace
	Error.prepareStackTrace = function(_, stack){ return stack }
	var err = new Error
	Error.captureStackTrace(err, top)
	var stack = err.stack

	Error.prepareStackTrace = orig
	Error.stackTraceLimit = origLimit

	return stack;
}

/*
All probabilistic function definitions must be wrapped with this decorator
so that they can be tagged with a lexically unique name (unfortunately, V8
doesn't expose details about where a function was defined *grumble*)
*/
function prob(fn)
{
	var frame = getStack(0, 1)[0]
	var fileName = frame.getFileName()
	var uniqId = fileNameTable.idForName(fileName)
	var fnName = ['(', uniqId, frame.pos, ')'].join(':')
	fn.__probabilistic_lexical_id = fnName
	return fn
}

/*
If a function wasn't wrapped with the above decorator,
this bit of code will cause us to throw an error when we attempt
to generate ERPs within that function
*/
// TODO: IMPLEMENT THIS!!!!!


/*
Variables generated by ERPs
*/
function RandomVariableRecord(erp, params, val, logprob, structural, conditioned)
{
	this.erp = erp
	this.params = params
	this.val = val
	this.logprob = logprob
	this.active = true
	this.structural = structural
	this.conditioned = conditioned
}

RandomVariableRecord.prototype.copy = function()
{
	return new RandomVariableRecord(this.erp, this.params, this.val,
									this.logprob, this.structural, this.conditioned)
}


/*
Execution trace generated by a probabilistic program.
Tracks the random choices made and accumulates probabilities.
*/
function RandomExecutionTrace(computation, doRejectionInit)
{
	doRejectionInit = (doRejectionInit == undefined ? true : doRejectionInit)
	this.computation = computation
	this.vars = {}
	this.logprob = 0.0
	this.newlogprob = 0.0
	this.oldlogprob = 0.0
	this.rootframe = null
	this.loopcounters = {}
	this.conditionsSatisfied = false
	this.returnValue = null

	if (doRejectionInit)
	{
		while (!this.conditionsSatisfied)
		{
			this.vars = {}
			this.traceUpdate()
		}
	}
}

RandomExecutionTrace.prototype.deepcopy = function()
{
	var newdb = new RandomExecutionTrace(this.computation, false)
	newdb.logprob = this.logprob
	newdb.oldlogprob = this.oldlogprob
	newdb.newlogprob = this.newlogprob
	newdb.conditionsSatisfied = this.conditionsSatisfied
	newdb.returnValue = this.returnValue

	for (var name in this.vars)
		newdb.vars[name] = this.vars[name].copy()

	return newdb
}

RandomExecutionTrace.prototype.freeVarNames = function(structural, nonstructural)
{
	structural = (structural == undefined ? true : structural)
	nonstructural = (nonstructural == undefined ? true : nonstructural)
	var names = []
	for (var name in this.vars)
	{
		var rec = this.vars[name]
		if (!rec.conditioned &&
			((structural && rec.structural) || (nonstructural && !rec.structural)))
			names.push(name)
	}
	return names
}

/*
Names of variables that this trace has that the other does not
*/
RandomExecutionTrace.prototype.varDiff = function(other)
{
	var arr = []
	for (var name in this.vars)
	{
		if (!other.vars[name])
			arr.push(name)
	}
	return arr
}

/*
Difference in log probability between this trace and the other
due to variables that this one has that the other does not
*/
RandomExecutionTrace.prototype.lpDiff = function(other)
{
	return this.varDiff(other)
		.map(function(name) {return this.vars[name].logprob})
		.reduce(function(a,b) {return a+b})
}

/*
The singleton trace object
*/
var trace = null

/*
Run computation and update this trace accordingly
*/
RandomExecutionTrace.prototype.traceUpdate = function()
{
	var origtrace = trace
	trace = this

	this.logprob = 0.0
	this.newlogprob = 0.0
	this.loopcounters = {}
	this.conditionsSatisfied = true

	// Mark all variables as inactive; only those reached
	// by the computation will become active
	for (var name in this.vars)
		this.vars[name].active = false

	// Mark that this is the 'root' frame of the computation
	this.rootframe = getStack(0, 1)[0]

	// Run the computation, creating/looking up random variables
	this.returnValue = this.computation()

	// Clean up
	this.rootframe = null
	this.loopcounters = {}

	// Clear out any random values that are no longer reachable
	var newvars = {}
	for (var name in this.vars)
	{
		var rec = this.vars[name]
		if (!rec.active)
			this.oldlogprob += rec.logprob
		else
			newvars[name] = rec
	}
	this.vars = newvars

	// Reset the original singleton trace
	trace = origtrace
}

module.exports =
{
	prob: prob
}